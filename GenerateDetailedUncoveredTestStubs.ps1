# CONFIGURATION
$coverageReport = "tests/Users.UnitTests/TestResults/402f0bc2-45bc-4e89-9e5f-333fe6beac9a/coverage.cobertura.xml"
$srcDir = "src"
$testDir = "tests/Users.UnitTests/AutoGenerated"

# Ensure output directory exists
if (-not (Test-Path $testDir)) {
    New-Item -ItemType Directory -Path $testDir | Out-Null
}

# Parse Cobertura XML for uncovered classes
[xml]$xml = Get-Content $coverageReport
$uncoveredClasses = $xml.coverage.packages.package.classes.class | Where-Object { $_.'line-rate' -eq "0" }

foreach ($class in $uncoveredClasses) {
    # Skip compiler-generated or nested classes
    if ($class.name -like '*+*' -or $class.name -like '<*>') { continue }

    # Find the source file for the class
    $filename = $class.filename -replace '\\','/'
    $srcFile = Join-Path $srcDir $filename
    if (-not (Test-Path $srcFile)) {
        Write-Host "Source file not found: $srcFile"
        continue
    }

    $content = Get-Content $srcFile -Raw

    # Find the namespace
    $namespaceMatch = [regex]::Match($content, 'namespace\s+([a-zA-Z0-9_.]+)')
    $namespace = if ($namespaceMatch.Success) { $namespaceMatch.Groups[1].Value } else { "AutoGenerated" }

    # Find all public classes in the file
    $classPattern = "public\s+class\s+([a-zA-Z0-9_]+)"
    $classMatches = [regex]::Matches($content, $classPattern)
    foreach ($classMatch in $classMatches) {
        $className = $classMatch.Groups[1].Value
        # Only generate for the uncovered class
        if ($className -ne ($class.name.Split('.')[-1])) { continue }

        # Find all public methods in the class
        $methodPattern = "public\s+(static\s+)?([a-zA-Z0-9_<>,\[\]]+)\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)"
        $methodMatches = [regex]::Matches($content, $methodPattern)

        if ($methodMatches.Count -eq 0) { continue }

        $testFile = Join-Path $testDir "${className}Tests.cs"
        $testClassHeader = @"
using Xunit;

namespace $namespace.Tests
{
    public class ${className}Tests
    {
"@

        $testClassFooter = @"
    }
}
"@

        $testMethods = @()
        foreach ($methodMatch in $methodMatches) {
            $methodName = $methodMatch.Groups[3].Value
            $params = $methodMatch.Groups[4].Value
            $paramList = @()
            if ($params.Trim() -ne "") {
                $paramPairs = $params.Split(",")
                foreach ($pair in $paramPairs) {
                    $typeAndName = $pair.Trim() -split "\s+"
                    if ($typeAndName.Length -eq 2) {
                        $paramList += "$($typeAndName[1]): $($typeAndName[0])"
                    }
                }
            }
            $paramArgs = ($paramList | ForEach-Object { $_.Split(":")[0].Trim() }) -join ", "
            $paramArrange = ($paramList | ForEach-Object { "            var $($_.Split(':')[0].Trim()) = default($($_.Split(':')[1].Trim()));" }) -join "`n"

            $testMethod = @"
        [Fact]
        public void ${methodName}_Should_BehaveAsExpected()
        {
$paramArrange
            // TODO: Instantiate class under test

            // Act
            // var result = instance.$methodName($paramArgs);

            // Assert
            // TODO: Add assertions
        }
"@
            $testMethods += $testMethod
        }

        # Write or overwrite the test file
        $testContent = $testClassHeader + ($testMethods -join "`n") + $testClassFooter
        $testContent | Out-File $testFile -Encoding utf8
        Write-Host "Generated: $testFile"
    }
}