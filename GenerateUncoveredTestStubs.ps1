<#
.SYNOPSIS
  Generate xUnit test stubs (methods + ctor/property) for all classes with 0% coverage.

.DESCRIPTION
  - Reads your Cobertura report under tests/Users.UnitTests/TestResults.
  - For each class with line-rate="0":
      • Parses public methods → generates Arrange/Act/Assert stubs.
      • If no methods, parses public ctor → generates ctor‑parameter and default‑property tests.
      • If neither, emits a single placeholder test.
  - Writes each test class to tests/Users.UnitTests/AutoGenerated/<Namespace>/<TypeName>Tests.cs.
#>

param(
    [string]$CoverageGlob = "tests/Users.UnitTests/TestResults/402f0bc2-45bc-4e89-9e5f-333fe6beac9a/coverage.cobertura.xml",
    [string]$SrcDir       = "src",
    [string]$TestBaseDir  = "tests/Users.UnitTests\AutoGenerated"
)

# 1) Find the Cobertura report
$report = Get-ChildItem -Path $CoverageGlob -File -Recurse -ErrorAction SilentlyContinue |
          Select-Object -First 1
if (-not $report) {
    Write-Error "Coverage report not found."
    exit 1
}
Write-Host "Using coverage report: $($report.FullName)"

# 2) Ensure output root exists
if (-not (Test-Path $TestBaseDir)) {
    New-Item -ItemType Directory -Path $TestBaseDir -Force | Out-Null
}

# 3) Load XML and select uncovered classes
[xml]$xml       = Get-Content $report.FullName
$uncovered      = $xml.coverage.packages.package.classes.class |
                  Where-Object { $_.'line-rate' -eq '0' }

foreach ($cls in $uncovered) {
    # skip nested or compiler-generated names
    if ($cls.name -match '[\+<]') { continue }

    # 4) Derive namespace folder + type name
    $cleanName = $cls.name -replace '[^A-Za-z0-9_.]', '_'       # sanitize
    $parts     = $cleanName -split '[._]'
    $nsFolder  = $parts[0]
    $typeName  = $parts[-1]

    # 5) Prepare output file
    $outDir   = Join-Path $TestBaseDir $nsFolder
    if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir -Force | Out-Null }
    $testFile = Join-Path $outDir "${typeName}Tests.cs"
    if (Test-Path $testFile) {
        Write-Host "Skipped (exists): $testFile"
        continue
    }

    #
    # --- Begin stub generation ---
    #

    # locate & read source
    $srcFile = Join-Path $SrcDir ($cls.filename -replace '/', '\')
    if (-not (Test-Path $srcFile)) {
        Write-Warning "Source not found: $srcFile"
        continue
    }
    $code = Get-Content $srcFile -Raw

    # extract full namespace (fallback to folder)
    $nsMatch = [regex]::Match($code, 'namespace\s+([A-Za-z0-9_.]+)')
    $fullNs  = if ($nsMatch.Success) { $nsMatch.Groups[1].Value } else { $nsFolder }

    # gather members
    $methodPattern = 'public\s+(static\s+)?([A-Za-z0-9_<>\[\], ]+)\s+([A-Za-z0-9_]+)\s*\(([^)]*)\)'
    $methodMatches = [regex]::Matches($code, $methodPattern)
    $ctorMatch     = [regex]::Match($code, "public\s+${typeName}\s*\(([^)]*)\)")
    $propPattern   = 'public\s+([A-Za-z0-9_<>\[\], ]+)\s+([A-Za-z0-9_]+)\s*\{\s*get;\s*set;\s*\}'
    $propMatches   = [regex]::Matches($code, $propPattern)

    # header & footer
    $header = @"
using Xunit;

namespace ${fullNs}.Tests
{
    public class ${typeName}Tests
    {
"@
    $footer = @"
    }
}
"@

    $bodyStubs = @()

    if ($methodMatches.Count -gt 0) {
        # A) Methods → Arrange/Act/Assert
        foreach ($m in $methodMatches) {
            $isStatic   = $m.Groups[1].Value -ne ""
            $returnType = $m.Groups[2].Value.Trim()
            $methodName = $m.Groups[3].Value
            $paramStr   = $m.Groups[4].Value.Trim()

            # parse params
            $decls = @(); $names = @()
            if ($paramStr) {
                $paramStr.Split(',') | ForEach-Object {
                    $parts = $_.Trim() -split '\s+'
                    if ($parts.Length -eq 2) {
                        $decls += "            var $($parts[1]) = default($($parts[0]));"
                        $names += $parts[1]
                    }
                }
            }
            $args = $names -join ', '

            # Act
            if ($isStatic) {
                $act = "            var result = ${typeName}.$methodName($args);"
            } else {
                $act = @"
            var sut    = new ${typeName}();
            var result = sut.$methodName($args);
"@.TrimEnd()
            }

            # Assert
            $assert = if ($returnType -ne 'void') {
                "            Assert.IsType<$returnType>(result);"
            } else {
                "            // no return value to assert"
            }

            $bodyStubs += @"
        [Fact]
        public void ${methodName}_Should_BehaveAsExpected()
        {
            // Arrange
$($decls -join "`n")

            // Act
$act

            // Assert
$assert
        }
"@
        }
    }
    elseif ($ctorMatch.Success) {
        # B) Constructor → param & default‑property tests
        $paramList = $ctorMatch.Groups[1].Value.Trim()
        $ctorDecls = @(); $ctorNames = @()
        if ($paramList) {
            $paramList.Split(',') | ForEach-Object {
                $p = $_.Trim() -split '\s+'
                if ($p.Length -eq 2) {
                    $ctorDecls += "            var $($p[1]) = default($($p[0]));"
                    $ctorNames += $p[1]
                }
            }
        }
        $ctorArgs = $ctorNames -join ', '

        # per‑parameter test
        foreach ($n in $ctorNames) {
            $bodyStubs += @"
        [Fact]
        public void Ctor_Should_Set_${n}_Property()
        {
            // Arrange
$($ctorDecls -join "`n")

            // Act
            var instance = new ${typeName}($ctorArgs);

            // Assert
            Assert.Equal($n, instance.$n);
        }
"@
        }

        # default for other auto‑props
        $setProps = New-Object 'System.Collections.Generic.HashSet[System.String]'
        $ctorNames | ForEach-Object { $setProps.Add($_) | Out-Null }
        foreach ($pm in $propMatches) {
            $pt = $pm.Groups[1].Value.Trim()
            $pn = $pm.Groups[2].Value.Trim()
            if (-not $setProps.Contains($pn)) {
                $bodyStubs += @"
        [Fact]
        public void Ctor_Should_Initialize_${pn}_ToDefault()
        {
            // Arrange
$($ctorDecls -join "`n")

            // Act
            var instance = new ${typeName}($ctorArgs);

            // Assert
            Assert.Equal(default($pt), instance.$pn);
        }
"@
            }
        }
    }
    else {
        # C) Fallback stub
        $bodyStubs += @"
        [Fact]
        public void TestMethod1()
        {
            // TODO: implement tests for $typeName
        }
"@
    }

    # 6) Write out
    $all = $header + ($bodyStubs -join "`n") + $footer
    $all | Out-File -FilePath $testFile -Encoding utf8 -Force
    Write-Host "Created: $testFile"

    #
    # --- End stub generation ---
    #
}
